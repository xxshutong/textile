<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
 Copyright (c) Open Source Strategies, Inc.

 Opentaps is free software: you can redistribute it and/or modify it
 under the terms of the GNU Affero General Public License as published
 by the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 Opentaps is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with Opentaps.  If not, see <http://www.gnu.org/licenses/>.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>opentaps 2 Notes Application</title>

<style type="text/css">

#content {
  margin-left: 20px;
  font-family: Verdana, Arial, Helvetica, sans-serif;
  font-size: 80%;
}

#content h1 {
  font-size: 100%;
  padding: 5px 0px 2px 4px;
}

.savebutton {
   background-color:#007e00;
   cursor:pointer;
   padding:10px;
   position:relative;
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-size:120%;
   text-decoration:none;
   color:#fff;
   border: solid 1px #831212;
   border-radius: 5px;
}

.savebutton:active {
   padding-bottom:9px;
   padding-left:10px;
   padding-right:10px;
   padding-top:11px;
   top:1px;
}

input[disabled] {
   background-color: #7a7a7a;
   color:#fff;
}

.logoutbutton {
   background-color:#888888;
   cursor:pointer;
   padding:8px;
   font-family: Verdana, Arial, Helvetica, sans-serif;
   font-size:100%;
   text-decoration:none;
   color:#fff;
   border: solid 1px #666666;
   border-radius: 5px;
}

.errorMessage,
.message,
.fieldErrorMessage
{
  font-family: Verdana, Arial, Helvetica, sans-serif;
  font-size: 100%;
  padding: 5px 0px 2px 4px;
}

.fieldErrorMessage,
.errorMessage { color:red; }

#noteList { width:60em; border:1px solid #666; margin:10px; padding:10px;}
#noteList .listHeader { font-weight:bold; margin-bottom:0.3em; border-bottom:1px dotted #AAA; }
#noteList .listRow > div { float:left; overflow:hidden; text-overflow:ellipsis; padding: .4em; }
#noteList .listRow .noteHeader { float:none; }
#noteList .listRow .noteHeader div { display:inline; }
#noteList .listRow .noteEnd { clear:left; float:none; padding:0; }
#noteList .noteAttribute { display:none; }
#noteList .noteId { display:none; }
#noteList .noteSequence { display:none; }
#noteList .noteText { }
#noteList .listRow:nth-child(even) {background: #DDD;}
#noteList .listRow:nth-child(odd) {background: #FFF;}
#loadingSpinner { padding:20px; text-align:center; }

.hidden { display:none; }

</style>

<script language="javascript" type="text/javascript">

function createRequest() {
  var xmlhttp;
  if (typeof XMLHttpRequest != 'undefined') {
    return new XMLHttpRequest();
  }
  try {
    xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
  } catch (e) {
    try {
      xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    } catch (e) {
      xmlhttp = false;
    }
  }
  return xmlhttp
}

function parseResponse(req) {
  var resp = req.responseText;
  switchButtonDisable(document.getElementById('createNoteButton'), false, "Create Note");

  if (resp) {
    var json = eval('(' + resp + ')');

    if (req.status == 201) {
      showErrorMessage("");
      showSuccessMessage(json.result.successMessage);
      document.getElementById('noteText').value = "";
      // fetch new notes for display in the list
      ajaxLoadLaterNotes();
    } else {
      showSuccessMessage("");
      showErrorMessage(json.result.errorMessage.replace(/\n/g,'<br/>'), json.result.errorDetail);
      if (req.status == 401) {
        showLoginPrompt();
      }
    }

  } else {
    showSuccessMessage("");
    showErrorMessage("Cannot get response from server.");
  }

}

function showErrorMessage(message, details) {
    document.getElementById('errorMessage').innerHTML = message;
    // reset field errors
    var els = document.getElementById('createNote').getElementsByTagName("div");
    var elsLen = els.length;
    var pattern = new RegExp("(^|\\s)fieldErrorMessage(\\s|$)");
    for (i = 0, j = 0; i < elsLen; i++) {
        if (pattern.test(els[i].className)) {
            els[i].innerHTML = "";
        }
    }
    // check field errors in the details
    if (details) {
        var len = details.length;
        for (var i=0; i < len; i++) {
            var detail = details[i];
            var el = document.getElementById(detail.field + '_error');
            if (el) {
                el.innerHTML = detail.message;
            }
        }
    }
}

function showSuccessMessage(message) {
    document.getElementById('successMessage').innerHTML = message;
}

function saveNote(form){
  switchButtonDisable(document.getElementById('createNoteButton'), true, "Please Wait...");
  var req = createRequest();

  // Create the callback:
  req.onreadystatechange = function() {
    if (req.readyState == 4) {
        parseResponse(req);
    }

  }

  var params = 'noteText=' + encodeURIComponent(form["noteText"].value);
  params = params + '&userKey=' + encodeURIComponent(document.getElementById('userKey').value);
  var postOnMyWall = document.getElementById('postOnMyWall').checked;
  if (postOnMyWall) {
    params = params + '&postOnMyWall=Y';
  } else {
    params = params + '&postOnMyWall=N';
  }

  req.open("POST", "http://localhost:8080/notes/note", true);
  req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

  req.send(params);

}

function switchButtonDisable(button, disabled, buttonText) {
  if (button) {
    button.disabled = disabled;
    button.value = buttonText;
  }
}

function getQueryVariable(variable) {
  var query = window.location.search.substring(1);
  var vars = query.split("&");
  for (var i=0;i<vars.length;i++) {
    var pair = vars[i].split("=");
    if (pair[0] == variable) {
      return pair[1];
    }
  }
  return "";
}

function showLoginPrompt() {
    var userLogin = document.getElementById("userLogin");
    if (userLogin) {
        userLogin.style.display = "inline";
    }
}

function getUser(userKey) {
    var reqUser = createRequest();

    // Create the callback:
    reqUser.onreadystatechange = function() {
        if (reqUser.readyState == 4) {
            parseUserResponse(reqUser);
        }
    }

    reqUser.open("GET", "http://localhost:8080/notes/user/"+userKey, true);

    reqUser.send(null);
}

/**
  Facebook Sign In integration is configured in org.opentaps.notes.rest.FacebookResource in the notes.rest module
***/
function login() {
    window.location.href = "http://localhost:8080/notes/facebook/login";
}

function parseUserResponse(req) {
    var resp = req.responseText;
    showSuccessMessage("");
    showErrorMessage("");

    if (resp) {
        var json = eval('(' + resp + ')');

        if (req.status == 200) {
            showUserArea(json);
        } else {
            showSuccessMessage("");
            showErrorMessage(json.result.errorMessage.replace(/\n/g,'<br/>'), json.result.errorDetail);
            showLoginPrompt();
        }

    } else {
        showErrorMessage("Cannot get response from server.");
    }
}

function showUserArea(json) {
    var userArea = document.getElementById('userArea');
    if (userArea) {
        userArea.innerHTML = json.result.successMessage + " " + json.result.resultValue.user.name;
    }
    var userAreaPhoto = document.getElementById('userAreaPhoto');
    if (userAreaPhoto) {
        userAreaPhoto.src = "https://graph.facebook.com/" + json.result.resultValue.user.id + "/picture?type=square";
        userAreaPhoto.style.display = "inline";
    }
    var userLogout = document.getElementById('userLogout');
    if (userLogout) {
        userLogout.style.display = "block";
    }
    var postOnMyWall = document.getElementById('postOnMyWall');
    if (postOnMyWall) {
        postOnMyWall.style.display = "inline";
    }
    var postOnMyWallLabel = document.getElementById('postOnMyWallLabel');
    if (postOnMyWallLabel) {
        postOnMyWallLabel.style.display = "inline";
    }
}

function hideUserArea(json) {
    var userArea = document.getElementById('userArea');
    if (userArea) {
        userArea.innerHTML = "";
    }
    var userAreaPhoto = document.getElementById('userAreaPhoto');
    if (userAreaPhoto) {
        userAreaPhoto.src = "";
        userAreaPhoto.style.display = "none";
    }
    var userLogout = document.getElementById('userLogout');
    if (userLogout) {
        userLogout.style.display = "none";
    }
    var postOnMyWall = document.getElementById('postOnMyWall');
    if (postOnMyWall) {
        postOnMyWall.style.display = "none";
    }
    var postOnMyWallLabel = document.getElementById('postOnMyWallLabel');
    if (postOnMyWallLabel) {
        postOnMyWallLabel.style.display = "none";
    }
}

function parseLogoutUserResponse(req) {
    var resp = req.responseText;
    showSuccessMessage("");
    showErrorMessage("");

    if (resp) {
        if (req.status == 200) {
            var userKey = getQueryVariable("userKey");
            document.getElementById('userKey').value = "";
            hideUserArea();
            showLoginPrompt();
        }
    } else {
        showErrorMessage("Cannot get response from server.");
    }
}

function logout() {
    var reqLogoutUser = createRequest();
    var userKey = document.getElementById('userKey');

    // Create the callback:
    reqLogoutUser.onreadystatechange = function() {
        if (reqLogoutUser.readyState == 4) {
            parseLogoutUserResponse(reqLogoutUser);
        }
    }

    reqLogoutUser.open("POST", "http://localhost:8080/notes/user/logout/"+userKey.value, true);
    reqLogoutUser.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

    reqLogoutUser.send(null);
}

// add object into HTML5 localStorage
Storage.prototype.setObject = function(key, value) {
    this.setItem(key, JSON.stringify(value));
}

Storage.prototype.getObject = function(key, defaultValue) {
    var value = this.getItem(key);
    if (value) {
       return JSON.parse(value);
    } else {
       return defaultValue;
    }
}



var notes = {};
notes.numberOfNotesPerPage = localStorage.getObject("numberOfNotesPerPage", 10);
notes.latestNote = undefined;
notes.oldestNote = undefined;
notes.loadedNotes = localStorage.getObject("notes", {});
notes.loadedNotesCount = 0;
notes.cachedNotesArray = new Array();
notes.loadNotesScrollThreshold = 200;
notes.loading = false;
notes.direction = "DESC";
notes.latestDisplayedNoteSequence = undefined;
notes.oldestDisplayedNoteSequence = undefined;

function formatDate(d) {
    if (!d) return "";
    var months = new Array("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December");
    var days = new Array("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday");
    return months[d.getMonth()] + " " + d.getDate() + ", " + d.getFullYear() + " " + ((d.getHours() < 10 ? '0' : '') + d.getHours()) + ":" + ((d.getMinutes() < 10 ? '0' : '') + d.getMinutes());
}

function createNoteElement(note) {

    var dateCreated = formatDate(new Date(note.dateTimeCreated));
    var userName = "anonymous";
    if (note.createdByUserId && note.createdByUserId != "") {
       userName = note.createdByUserId;
    }

    var noteEl = document.createElement("div");
    noteEl.className = "note listRow";
    noteEl.id = note.noteId;

    var idEl = document.createElement("div");
    idEl.className = "noteId";
    idEl.appendChild(document.createTextNode(note.noteId));
    noteEl.appendChild(idEl);

    // the header includes date and user name
    var headerEl = document.createElement("div");
    headerEl.className = "noteHeader";

    var dateEl = document.createElement("div");
    dateEl.className = "date";
    dateEl.appendChild(document.createTextNode(dateCreated));

    var userEl = document.createElement("div");
    userEl.className = "userName";
    userEl.appendChild(document.createTextNode(userName));

    headerEl.appendChild(dateEl);
    headerEl.appendChild(document.createTextNode(" by "));
    headerEl.appendChild(userEl);
    headerEl.appendChild(document.createTextNode(" : "));
    noteEl.appendChild(headerEl);

    var imgCtEl = document.createElement("div");
    imgCtEl.className = "userPicture";
    var imgEl;
    if (note.createdByUserId && note.createdByUserId != "") {
      imgEl = document.createElement("img");
      imgEl.src = "https://graph.facebook.com/" + note.createdByUserId + "/picture?type=square";
    } else {
      imgEl = document.createElement("div");
      imgEl.className = "noImage";
    }
    imgCtEl.appendChild(imgEl);
    noteEl.appendChild(imgCtEl);

    var seqEl = document.createElement("div");
    seqEl.className = "noteSequence";
    seqEl.appendChild(document.createTextNode(note.sequenceNum));
    noteEl.appendChild(seqEl);

    var textEl = document.createElement("div");
    textEl.className = "noteText";
    textEl.appendChild(document.createTextNode(note.noteText));
    noteEl.appendChild(textEl);

    for (var i = 1; i <= 10; i++) {
        var attEl = document.createElement("div");
        attEl.className = "noteAttribute";
        attEl.appendChild(document.createTextNode(note['attribute' + i]));
        noteEl.appendChild(attEl);
    }

    var endEl = document.createElement("div");
    endEl.className = "noteEnd";
    noteEl.appendChild(endEl);

    return noteEl;
}

function loadNotes(noteList) {
    var n = noteList.length;

    if (n > 0) {
       var prev = document.createDocumentFragment();
       var firstNew;
       var next = document.createDocumentFragment();
       var container = document.getElementById("notesContainer");

       // in case the noteList includes the already displayed list we would have to insert the new notes
       // before or after according to their sequence, using notes.latestDisplayedNoteSequence / notes.oldestDisplayedNoteSequence

       for (var i = 0; i < n; i++) {
           var note = noteList[i];
           if (note.note) note = note.note;
           // save to localStorage
           notes.loadedNotes[note.noteId] = note;
           var noteEl = createNoteElement(note);
           var existing = document.getElementById(note.noteId);
           if (existing) {
               console.log("replacing existing note Node for " + note.sequenceNum);
               existing.parentNode.replaceChild(noteEl, existing);
           } else {
               if ("DESC" != notes.direction) {
                   if (note.sequenceNum >= notes.latestDisplayedNoteSequence) {
                       console.log("appending note " + note.sequenceNum);
                       next.appendChild(noteEl);
                   } else {
                       console.log("prepending note " + note.sequenceNum);
                       if (firstNew) prev.insertBefore(noteEl, firstNew);
                       else prev.appendChild(noteEl);
                   }
               } else {
                   if (note.sequenceNum >= notes.latestDisplayedNoteSequence) {
                       console.log("prepending note " + note.sequenceNum);
                       if (firstNew) prev.insertBefore(noteEl, firstNew);
                       else prev.appendChild(noteEl);
                   } else {
                       console.log("appending note " + note.sequenceNum);
                       next.appendChild(noteEl);
                   }
               }
           }
           onNoteLoaded(note, true);
       }
       notes.loadedNotesCount += n;
       container.appendChild(next);
       container.insertBefore(prev, container.firstChild);
    }

    console.log("loaded " + n + " new notes");
    onNotesLoaded(n);
}

function onNoteLoaded(note, displayed) {
    if (!note) {
        console.log("onNoteLoaded called on empty note !");
        return;
    }
    if (!notes.oldestNote || (notes.oldestNote.sequenceNum > note.sequenceNum)) notes.oldestNote = note;
    if (!notes.latestNote || (notes.latestNote.sequenceNum < note.sequenceNum)) notes.latestNote = note;
    if (displayed) {
        if (!notes.oldestDisplayedNoteSequence || (notes.oldestDisplayedNoteSequence > note.sequenceNum)) {
            notes.oldestDisplayedNoteSequence = note.sequenceNum;
        }
        if (!notes.latestDisplayedNoteSequence || (notes.latestDisplayedNoteSequence < note.sequenceNum)) {
            notes.latestDisplayedNoteSequence = note.sequenceNum;
        }
    }
}

function onNotesLoaded(n) {
    localStorage.setObject("notes", notes.loadedNotes);
    notesLoadingDone();
    // check the list position and see if more loading is needed
    // which is when the list did not got to the end of the page
    if (n > 0) loadIfScrolledToEndOfList();
}

function initCachedNotesArray() {
    // notes are stored in localStorage as id -> note
    // first we want to order them back by sequenceNum
    for (var id in notes.loadedNotes) {
        var note = notes.loadedNotes[id];
        notes.cachedNotesArray.push(note);
        onNoteLoaded(note);
    }
    notes.cachedNotesArray.sort(compareNoteSequence);
    if ("DESC" == notes.direction) notes.cachedNotesArray.reverse();
    notes.loadedNotesCount = notes.cachedNotesArray.length;
    console.log("initCachedNotesArray complete, loaded [" + notes.loadedNotesCount + "] in [" + notes.direction + "] order");
}

// binary search in notes.cachedNotesArray, returns the biggest index of the note element
// where note.sequenceNum >= given sequenceNum
//  or   note.sequenceNum <= given sequenceNum  if direction is DESC
function searchLoadedNote(sequence) {
    var low = 0, n = notes.cachedNotesArray.length, i = -1, high = n - 1;
    while (low <= high) {
        i = Math.floor((low + high) / 2);
        if ("DESC" == notes.direction) {
          if(notes.cachedNotesArray[i].sequenceNum > sequence) { low = i + 1; continue; }
          else if(notes.cachedNotesArray[i].sequenceNum < sequence) { high = i - 1; continue; };
        } else {
          if(notes.cachedNotesArray[i].sequenceNum < sequence) { low = i + 1; continue; }
          else if(notes.cachedNotesArray[i].sequenceNum > sequence) { high = i - 1; continue; };
        }
        return i;
    }
    if (i == -1) return i;
    if ("DESC" == notes.direction) {
      if (notes.cachedNotesArray[i].sequenceNum > sequence && i < (n - 1)) return i + 1;
    } else {
      if (notes.cachedNotesArray[i].sequenceNum < sequence && i < (n - 1)) return i + 1;
    }
    return i;
}

function compareNoteSequence(a, b) {
    return a.sequenceNum - b.sequenceNum;
}

function notesLoadingStart() {
    var spinner = document.getElementById("loadingSpinner");
    if (spinner) spinner.className = "";
    notes.loading = true;
}

function notesLoadingDone() {
    var spinner = document.getElementById("loadingSpinner");
    if (spinner) spinner.className = "hidden";
    notes.loading = false;
    console.log("Done loading.");
}

function loadNoteList() {
    if (notes.loading) {
        console.log("loadNoteList : not loading more, request still in progress ...");
        return;
    }

    if (notes.latestNote) {
        console.log("cached : [" + notes.oldestNote.sequenceNum + " - " + notes.latestNote.sequenceNum + "] displayed : [" + notes.oldestDisplayedNoteSequence + " - " + notes.latestDisplayedNoteSequence + "]");
    }

    // if we are loading the latest first we have to it the server first to get the newest notes
    if ("DESC" == notes.direction && !notes.oldestDisplayedNoteSequence) {
       ajaxLoadNotes();
       //return;
    }

    // check if we have them in local storage already
    if (notes.latestNote) {
        var from, to;
        if ("DESC" != notes.direction) {
          // compare the latest note cached (notes.latestNote) with the latest displayed in the list notes.latestDisplayedNoteSequence
          // starting at the next latest (notes.latestDisplayedNoteSequence + 1)
          if (!notes.latestDisplayedNoteSequence || notes.latestNote.sequenceNum > (notes.latestDisplayedNoteSequence + 1)) {
            console.log("loading [" + notes.numberOfNotesPerPage + "] notes ASC using local storage ...");
            if (!notes.latestDisplayedNoteSequence) {
              from = 0;
            } else {
              // the cache is ordered [oldest to latest]
              from = searchLoadedNote(notes.latestDisplayedNoteSequence + 1);
            }
            if (from < notes.cachedNotesArray.length) {
                to = from + notes.numberOfNotesPerPage;
                loadNotes(notes.cachedNotesArray.slice(from, to));
                return;
            }
          }
        } else {
          // compare the oldest note cached (notes.oldestNote) with the oldest displayed in the list notes.oldestDisplayedNoteSequence
          // starting at the next oldest (notes.oldestDisplayedNoteSequence - 1)
          if (!notes.oldestDisplayedNoteSequence || notes.oldestNote.sequenceNum < (notes.oldestDisplayedNoteSequence - 1)) {
            console.log("loading [" + notes.numberOfNotesPerPage + "] notes DESC using local storage ...");
            if (!notes.oldestDisplayedNoteSequence) {
              from = 0;
            } else {
              // the cache is ordered [latest to oldest]
              from = searchLoadedNote(notes.oldestDisplayedNoteSequence - 1);
            }
            if (from < notes.cachedNotesArray.length) {
                to = from + notes.numberOfNotesPerPage;
                loadNotes(notes.cachedNotesArray.slice(from, to));
                return;
            }
            return;
          }
        }
    }

    ajaxLoadNextPage();
}

function ajaxLoadNotes(from, order) {

    if (!order) order = notes.direction;

    console.log("loading [" + notes.numberOfNotesPerPage + "] notes using AJAX from [" + from + "] order [" + order + "]");

    // get the notes from the REST api
    var loadNoteReq = createRequest();

    // Create the callback:
    loadNoteReq.onreadystatechange = function() {
        if (loadNoteReq.readyState == 4) {
            var resp = loadNoteReq.responseText;
            if (resp) {
                if (loadNoteReq.status == 200) {
                    var json = eval('(' + resp + ')');
                    loadNotes(json.result.resultValue);
                }
            } else {
                showErrorMessage("Cannot get response from server.");
                notesLoadingDone();
            }
        }
    }

    var query = "http://localhost:8080/notes/notes/" + notes.numberOfNotesPerPage;
    if (from) {
        query += "/" + from;
    }
    query += "?order=" + order;
    loadNoteReq.open("GET", query, true);
    loadNoteReq.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    notesLoadingStart();
    loadNoteReq.send(null);

}

function ajaxLoadNextPage() {
    if ("DESC" == notes.direction) {
        ajaxLoadOlderNotes();
    } else {
        ajaxLoadLaterNotes();
    }
}

function ajaxLoadLaterNotes() {
    var next;
    if (notes.latestNote) {
        next = notes.latestNote.sequenceNum + 1;
    }
    console.log("ajaxLoadLaterNotes : " + next);
    ajaxLoadNotes(next, "ASC");
}

function ajaxLoadOlderNotes() {
    var next;
    if (notes.oldestNote) {
        next = notes.oldestNote.sequenceNum - 1;
    }
    console.log("ajaxLoadOlderNotes : " + next);
    ajaxLoadNotes(next, "DESC");
}


function loadIfScrolledToEndOfList() {
    // when the window scroll to the end of the note list, try to load more notes
    var scrollTop = window.pageYOffset;
    var pageHeight = document.documentElement.clientHeight; 
    var contentHeight = document.documentElement.offsetHeight;
    //console.log("scrollTop = " + scrollTop + ", pageHeight = " + pageHeight + ", contentHeight = " + contentHeight + " ==> contentHeight - pageHeight - scrollTop = " + (contentHeight - pageHeight - scrollTop));
    if ((contentHeight - pageHeight - scrollTop) < notes.loadNotesScrollThreshold) {
        console.log("have not reached the bottom of the page, load more notes");
        loadNoteList();
        return true;
    }
    return false;
}

function scroll() {
    if (!notes.loading) loadIfScrolledToEndOfList();
}

function onLoadPage() {
    var userKey = getQueryVariable("userKey");
    document.getElementById("userKey").value = userKey;

    if (userKey == "") {
        showLoginPrompt();
    } else {
        getUser(userKey);
    }

    if (typeof localStorage == 'undefined') {
        alert("Your browser does not support HTML 5 local storage.");
    } else {
      // first display the notes from local storage
      initCachedNotesArray();
      // set the scroll handler
      window.onscroll = scroll;
      loadIfScrolledToEndOfList();
    }
}
</script>

</head>

<body onLoad="javascript:onLoadPage()">

<div id="container">
  <div id="content">
    <table style="width:518px">
     <tr>
       <td style="width:70%">
         <img src="http://www.opentaps.org/images/opentaps_logo.png"/>
       </td>
        <td align="right" style="width:30%">
          <div id="userLogin" style="display:none">
          <a href="javascript:login()"><img src="images/fb_login.png"></a>
          </div>
         <div id="userLogout" style="display:none">
           <input type="button" name="logoutButton" id="logoutButton" value="Logout" onClick="logout()" class="logoutbutton"/>
         </div>
       </td>
     </tr>
     <tr>
       <td valign="top" colspan="2">
         <label id="userArea"></label> <img style="display:none" id="userAreaPhoto" src="" height="25px"/>
       </td>
     </tr>
    </table>
    <input type="hidden" name="userKey" id="userKey"/>
    <form name="createNote" id="createNote" action="createNote" method="post">
    <table style="width:518px">
      <tr><td>
      <div class="fieldErrorMessage" id="noteText_error"></div>
      <textarea name="noteText" id="noteText" rows="6" cols="70" placeholder="Write your note here" style="width:100%"></textarea>
      </td></tr>
      <tr>
        <td>
          <input type="checkbox" name="postOnMyWall" id="postOnMyWall" style="display:none" checked="checked"/> <label id="postOnMyWallLabel" for="postOnMyWall" style="display:none">Also post on my wall</label>
        </td>
      </tr>
      <tr>
        <td>
          <input type="button" name="createNoteButton" id="createNoteButton" value="Create Note" onClick="saveNote(this.form)" class="savebutton"/>
        </td>
      </tr>
	  <tr><td>
        <div class="message" id="successMessage"></div>
        <div class="errorMessage" id="errorMessage"></div>
	  </td></tr>
    </table>
    </form>
  </div>

  <div id="noteList">
    <div id="notesContainer"></div>
    <div id="loadingSpinner" class="hidden"><img src="http://www.opentaps.org/images/spinner.gif"/></div>
  </div>

</div>

</body>
</html>
